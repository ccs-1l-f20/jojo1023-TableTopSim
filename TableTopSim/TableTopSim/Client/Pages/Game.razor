@page "/game/{PlayerId:int}/{RoomId:int}/"

@using Blazor.Extensions.Canvas
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas.Canvas2D;
@using System.Numerics;
@using GameLib;
@using System.Diagnostics;
@using System.Threading;
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

<img src="/images/cardBack.png" asp-append-version="true" @ref="CardBack" style="display:none" />

<div @onkeydown="@KeyDown" @onkeyup="@KeyUp" tabindex="0" @ref="globalDiv"></div>
<div @onmousemove="MouseMove" @onmousedown="MouseDown" @onmouseup="MouseUp" @ref="div">
    <BECanvas Width="@Width" Height="@Height" @ref="canvas"></BECanvas>
</div>

@code {
    [Parameter]
    public int PlayerId { get; set; }
    [Parameter]
    public int RoomId { get; set; }
    Size size = new Size(500, 500);
    long Width => size.Width;
    long Height => size.Height;
    bool renderUi = false;
    private Canvas2DContext context;
    protected BECanvasComponent canvas;
    Vector2 mousePos = Vector2.Zero;
    ElementReference div;
    ElementReference globalDiv;
    BoundingClientRect boundingClientRect;
    bool hasRendered = false;
    GameManager gameManager;
    ElementReference CardBack;
    CancellationTokenSource cts = new CancellationTokenSource();
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        NavigationManager.LocationChanged += OnLocationChanged;
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("SetFocusTo", globalDiv);
        }
        context = await canvas.CreateCanvas2DAsync();

        await context.ClearRectAsync(0, 0, Width, Height);
        ElementReferences elementReferences = new ElementReferences() { CardBack = CardBack };
        gameManager = new GameManager(size, elementReferences, PlayerId, RoomId);

        await Task.Run(async () => await Update(cts.Token));
    }
    void OnLocationChanged(object sender, LocationChangedEventArgs args)
    {
        cts.Cancel();
    }
    public async Task Update(CancellationToken ct)
    {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        while (true)
        {
            if (ct.IsCancellationRequested) { break;  }
            gameManager.Update(context, stopwatch.Elapsed, ct);
            long previousElapsedMilli = stopwatch.ElapsedMilliseconds;
            stopwatch.Restart();
            await Task.Delay((int)Math.Max(0, 16 - previousElapsedMilli), ct);
        }
    }
    void MouseUp(MouseEventArgs args)
    {
        if (hasRendered)
        {
            gameManager.MouseUp();
        }
    }
    void MouseDown(MouseEventArgs args)
    {
        if (hasRendered)
        {
            gameManager.MouseDown();
        }
    }
    void MouseMove(MouseEventArgs args)
    {
        if (hasRendered && boundingClientRect != null && gameManager != null)
        {
            mousePos = new Vector2((float)(args.ClientX - boundingClientRect.Left), (float)(args.ClientY - boundingClientRect.Top));
            gameManager.MouseMove(mousePos);
        }
    }
    protected override bool ShouldRender()
    {
        hasRendered = true;
        UpdateBoundingRect();
        return renderUi;
    }
    async void UpdateBoundingRect()
    {
        boundingClientRect = await JSRuntime.InvokeAsync<BoundingClientRect>
    ("MyDOMGetBoundingClientRect", div);
        await JSRuntime.InvokeVoidAsync("SetFocusTo", globalDiv);
    }

    void KeyDown(KeyboardEventArgs args)
    {
        gameManager.KeyDown(args);
    }
    void KeyUp(KeyboardEventArgs args)
    {
        gameManager.KeyUp(args);
    }
}
